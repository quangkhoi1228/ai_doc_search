TỔ CHỨC
- Mỗi phần tử chứa liên kết đến phần tử đứng liền trước và sau nó 
- Mỗi phần tử là một cấu trúc gồm 3 thành phần: 
	+ Thành phần dữ liệu: chứa thông tin cần quản lý 
	+ Hai thành phần liên kết: chứa địa chỉ của phần tử liền trước và sau nó, hoặc chứa giá trị NULL.
struct TenDulieu { 
	... // Thông tin cần quản lý }; 
	struct Node { 
		TenDulieu info; Node * pNext, * pPrev; }; 
	struct TenDS { Node *pHead, *pTail; };
CÁC THAO TÁC CƠ BẢN 
- Tạo danh sách rỗng 	
	void CreateList(TenDS &p) { p.pHead = NULL; p.pTail = NULL; } 
- Tạo một nút có trường info bằng x 
	Node* CreateNode(TenDuLieu x) { 
		Node *p = new Node; // cấp phát vùng nhớ 
		if (p != NULL) { // kiểm tra kết quả cấp phát 
			p->info = x; p->pPrev = NULL; p->pNext = NULL; } 
		return p; }

- Thêm phần tử vào danh sách 
	+ Thêm vào đầu danh sách 
		void AddFirst(TenDS &l, Node *p) { 
			if (l.pHead == NULL) { 
				l.pHead = p; l.pTail = p; } 
			else { p->pNext = l.pHead; l.pHead->pPrev=p; l.pHead = p; } 
		}
	+ Thêm vào cuối danh sách 
		void AddLast(TenDS &l, Node *p) { 
			if (l.pHead == NULL) { 
				l.pHead = p; l.pTail = p; } 
			else { l.pTail->pNext = p; p->pPrev = l.pTail; l.pTail = p; } 
		}
	+ Thêm vào sau phần tử q trong danh sách 
		void AddAfter(TenDS &l, Node *p, Node *q) { 
			if (q != NULL) { 
				p->pNext = q->pNext; 
				if (q->pNext != NULL) q->pNext->pPrev = p; q->pNext = p; p->pPrev = q; 
				if (l.pTail == q) l.pTail = p; } 
			else AddFirst(l, p); 
		}
	+  Thêm vào trước phần tử q trong danh sách 
		void AddBefore(TenDS &l, Node *p, Node *q) { 
			if (q != NULL) { p->pPrev = q->pPrev; 
				if (q->pPrev != NULL) q->pPrev->pNext = p; 
				q->pPrev = p; p->pNext = q;
				if (l.pHead == q) l.pHead = p; } 
			else AddLast(l, p); 
		}

- Duyệt danh sách 
B1) p <- l.pHead 
B2) Nếu p = NULL qua B4 
B3) Xử lý cho phần tử p, p <- p->pNext, qua B2. 
B4) Kết thúc
	+  Tìm phần tử có trường info bằng x 
		int Equal(TenDuLieu x, TenDuLieu y); // hàm so sánh 
		Node * Search(TenDS l, TenDuLieu x) { 
			Node *p = l.pHead; 
			while ((p != NULL) && (!Equal(p->info, x)) 
				p = p->pNext; return p; 
		}
- Hủy phần tử trong danh sách 
	+  Hủy phần tử đầu danh sách 
		int RemoveFirst(TenDS &l, TenDulieu &x) { 
			Node *p = l.pHead; int r = 0; 
			if (l.pHead != NULL) {
				 x = p->info; l.pHead = p->pNext; delete p; r = 1; if (l.pHead == NULL) l.pTail = NULL; else l.pHead->pPrev = NULL; }
			 return r; 
		}
	+  Hủy phần tử cuối danh sách 
		int RemoveLast(TenDS &l, TenDulieu &x) { 
			Node *p = l.pTail; int r = 0; 
			if (l.pTail != NULL) { x = p->info; l.pTail = p->pPrev; delete p; r = 1; if (l.pTail == NULL) l.pHead = NULL; else l.pTail->pNext = NULL; } 
			return r; 
		}
	+  Hủy phần tử ngay sau phần tử q trong danh sách 
		int RemoveAfter(TenDS &l, Node *q, TenDulieu &x) {
			Node *p; 
			if (q != NULL) { p = q->pNext; 
				if (p != NULL) { q->pNext = p->pNext; if (p==l.pTail) l.pTail=q; else p->pNext->pPrev=q; x = p->info; delete p; } 
			return 1;} 
			else return RemoveFirst(l, x); 
		}
	+  Hủy phần tử ngay trước phần tử q trong danh sách 
		int RemoveBefore(TenDS &l, Node *q, TenDulieu &x) { 
			Node *p; 
			if (q != NULL) { p = q->pPrev; 
				if (p != NULL) { q->pPrev = p->pPrev; if(p==l.pHead) l.pHead=q; else p->pPrev->pNext=q; x = p->info; delete p; } 
				return 1;} 
			return RemoveLast(l, x);
		}
	+  Hủy phần tử có khóa x 
		int Remove(TenDS &l, TenDulieu &x) { 
			Node *p = l.pHead, *q = NULL; int r = 0; 
			while ((p != NULL) && (!Equal(p->info, x))) { q = p; p = p->pNext; } if (p != NULL) 
				if (q == NULL) r = RemoveFirst(l,x); 
				else r = RemoveAfter(l, q, x); 
			return r; 
		}

- Hủy danh sách 
void RemoveList(TenDS &l) { 
	Node *p; while (l.pHead != NULL)  { 
		p = l.pHead; l.pHead = p->pNext; delete p; } 
	l.pTail = NULL;
}

- Sắp xếp danh sách 
Danh sách có thể được sắp xếp theo hai cách 
	+ Hoán đổi thành phần info của các phần tử trong danh sách 
	+ Thiết lập lại liên kết giữa các phần tử trong danh sách
